                        ; ****************************************************************************
                        ; ****************************************************************************
                        ;
                        ;                        RCA Studio II Space Invaders
                        ;
                        ;                    Written by Paul Robson September 2000
                        ;
                        ;	Modified September 2016 to not use Long Branches which cause display
                        ;	glitches. PSR.
                        ;
                        ; ****************************************************************************
                        ; ****************************************************************************
                        ;
                        ;       Register usage :
                        ;
                        ;       R0 R8 R9 RB.0   [Used in Interrupt Routine]
                        ;       R1              [Interrupt Vector]
                        ;       R2              [Stack Pointer]
                        ;       RE              Points to video RAM at $900
                        ;       RF              Points to program RAM at $800
                        ;       R5              Random Number Generator
                        ;
      = 0000            IOffset = $00                           ; Invader Offset ($800)
      = 0001            POffset = $01                           ; Player offset ($801)
      = 0002            ICount  = $02                           ; Invader Count ($802)
      = 0003            IStatus = $03                           ; Invader Status ($803)
      = 0004            IBase   = $04                           ; Bottom Scrolling Line ($804)
      = 0005            RSeed   = $05                           ; Random Seed ($805)
      = 000B            PScore  = $0B                           ; Player Score ($80B...$80E)
      = 000F            PLives  = $0F                           ; Player lives ($80)
      = 0010            FButton = $10                           ; Fire Button ($810)
                        ;
      = 0020            MTable  = $20                           ; Missile table ($20-$27, Offset,Mask)
                                                                ; 4 pairs of 2 byte data. Mask=0 => none

      = 0003            Lives  =  3                             ; Number of lives
      = 0002            BaseSpd = 2                             ; Speed of base

      = 0010            MCount =  8*2                           ; Total number of missiles, x 2

      = 00CD            SndTmr =  $CD                           ; $8CD is the Beep Timer
      = 00CE            TmrInv =  $CE                           ; Use $8CE as invader timer
      = 00CF            TmrPly =  $CF                           ; Use $8CF as player timer

      = 0000            ISLeft = 0                              ; Invader Status Mode (how it is moving)
      = 0001            ISDownLeft = 1
      = 0002            ISRight = 2
      = 0003            ISDownRight = 3

0000                            .include "1802.inc"
      = 0000            r0      = 0
      = 0001            r1      = 1
      = 0002            r2      = 2
      = 0003            r3      = 3
      = 0004            r4      = 4
      = 0005            r5      = 5
      = 0006            r6      = 6
      = 0007            r7      = 7
      = 0008            r8      = 8
      = 0009            r9      = 9
      = 000A            ra      = 10
      = 000B            rb      = 11
      = 000C            rc      = 12
      = 000D            rd      = 13
      = 000E            re      = 14
      = 000F            rf      = 15

0400                            .org    400h                    ; where RCA Studio II games start
0400  045D                      .db     >(Start),<(Start)  ; Internal Code call to Machine Code

                        ; ****************************************************************************
                        ;                               Invader Graphics
                        ;
                        ;       .x.....x!.....x..!...x....!             ; $41 $04 $10
                        ;       xxx...xx!x...xxx.!..xxx...!             ; $E3 $8E $38
                        ; ****************************************************************************

0402                    InvaderGr:
0402  388EE3                    .db     $38,$8E,$E3             ; bytes are right to left bottom to top
0405  100441                    .db     $10,$04,$41             ; this corresponds to the above graphic
0408  FF                        .db     $FF                     ; this means "miss a line"

0409  288AA2                    .db     $28,$8A,$A2
040C  100441                    .db     $10,$04,$41
040F  FF                        .db     $FF

0410  100441                    .db     $10,$04,$41
0413  388EE3                    .db     $38,$8E,$E3
0416  FF                        .db     $FF

0417  100441                    .db     $10,$04,$41
041A  288AA2                    .db     $28,$8A,$A2

041D  00                        .db     0                       ; end of the invaders

                        ; ****************************************************************************
                        ;     Scroll line at RE left 1 pixel. On exit RE points to previous line
                        ; ****************************************************************************

041E                    ScrollLeft:
041E  1E                        inc     re              ; get next byte
041F  0E                        ldn     re
0420  2E                        dec     re
0421  FE                        shl                     ; shift into carry
0422  0E                        ldn     re              ; read original byte
0423  7E                        shlc                    ; shift it left, shift in new.
0424  5E                        str     re              ; write back
0425  1E                        inc     re              ; next
0426  8E                        glo     re
0427  FA 07                     ani     $07
0429  3A 1E                     bnz     ScrollLeft      ; do complete line
042B  2E                        dec     re              ; zero right most pixel
042C  0E                        ldn     re
042D  FA FE                     ani     $FE
042F  5E                        str     re
0430  8E                        glo     re              ; previous line
0431  FF 0F                     smi     16-1
0433  AE                        plo     re
0434  D3                        sep     r3              ; return
0435  30 1E                     br      ScrollLeft


                        ; ****************************************************************************
                        ;     Scroll line at RE right 1 pixel. On exit RE points to previous line
                        ; ****************************************************************************

0437                    ScrollRight:
0437  FC 00                     adi     $00             ; clear DF
0439                    _SRight0:
0439  0E                        ldn     re              ; read byte
043A  76                        shrc                    ; shift it right, including old carry
043B  5E                        str     re              ; save it, old carry goes through
043C  1E                        inc     re              ; next byte
043D  8E                        glo     re
043E  FA 07                     ani     $07             ; done whole row ?
0440  3A 39                     bnz     _SRight0
0442  2E                        dec     re
0443  8E                        glo     re              ; previous line
0444  FF 0F                     smi     15
0446  AE                        plo     re
0447  D3                        sep     r3              ; return
0448  30 37                     br      ScrollRight

                        ; ****************************************************************************
                        ;        XORPlot all the missiles. This is done to move the invaders
                        ; ****************************************************************************

044A                    XORMissiles:
044A  F8 20                     ldi     MTable                  ; RF points to missiles
044C  AF                        plo     rf
044D  EE                        sex     re
044E  4F                _XOR1:  lda     rf                      ; Read offset
044F  AE                        plo     re                      ; RE now points to video byte
0450  4F                        lda     rf                      ; Read bitmask
0451  32 55                     bz      _XOR2
0453  F3                        xor                             ; toggle bit
0454  5E                        str     re                      ; update
0455  8F                _XOR2:  glo     rf                      ; done the lot ?
0456  FA 0F                     ani     MCount-1
0458  3A 4E                     bnz     _XOR1                   ; if not, do all 4 possibles
045A  D3                        sep     r3                      ; return
045B  30 4A                     br      XORMissiles             ; loop back for next call

                        ; ****************************************************************************
                        ;
                        ;                           Start of main program.
                        ;
                        ; ****************************************************************************

045D  F8 08             Start:  ldi     $08                     ; access data memory
045F  BF                        phi     rf
0460  F8 0F                     ldi     PLives
0462  AF                        plo     rf
0463  F8 03                     ldi     Lives                   ; set lives to 3
0465  EF                        sex     rf
0466  73                        stxd
0467  91                        ghi     r1                      ; zero four score bytes
0468  73                        stxd
0469  73                        stxd
046A  73                        stxd
046B  73                        stxd

                        ; ****************************************************************************
                        ;                              Start a new level
                        ; ****************************************************************************

046C                    NewLevel:

                        ; ****************************************************************************
                        ;                               Clear the screen
                        ; ****************************************************************************

046C  91                        ghi     r1                      ; D = 0
046D  AE                        plo     re
046E  EE                        sex     re                      ; use RF as index register
046F  F8 09             _Clear: ldi     $09                     ; RF = $0900
0471  BE                        phi     re                      ; initialise RE.1, stays $09
0472  91                        ghi     r1                      ; Write zero there
0473  73                        stxd
0474  8E                        glo     re
0475  3A 6F                     bnz     _Clear

                        ; ****************************************************************************
                        ;                       Draw All Invaders in Start Position
                        ; ****************************************************************************

0477  F8 5E                     ldi     11*8+6                  ; base position of invaders in RF
0479  AE                        plo     re
047A  F8 04                     ldi     InvaderGr / 256         ; set RE to point to the graphic data
047C  BC                        phi     rc
047D  F8 02                     ldi     InvaderGr & 255

047F                    _HalfLine:
047F  AC                        plo     rc
0480  AD                        plo     rd                      ; save the copy of it.
0481  4C                        lda     rc                      ; copy three bytes
0482  73                        stxd
0483  4C                        lda     rc
0484  73                        stxd
0485  4C                        lda     rc
0486  73                        stxd
0487  8E                        glo     re                      ; get the pointer. if LSBit is
0488  F6                        shr                             ; non-zero, go back.
0489  8D                        glo     rd                      ; and restore the pointer
048A  33 7F                     bdf     _HalfLine
048C  2E                        dec     re                      ; fix for next line
048D  2E                        dec     re

048E  0C                        ldn     rc                      ; look at next byte
048F  32 9D                     bz      _EndDrawInv             ; done if zero
0491  FB FF                     xri     $FF                     ; check if $FF
0493  3A 9A                     bnz     _NoSkip
0495  1C                        inc     rc                      ; if so, skip byte and go up a line
0496  8E                        glo     re
0497  FF 08                     smi     8
0499  AE                        plo     re
049A                    _NoSkip:                                ; go back
049A  8C                        glo     rc                      ; prepare for PLO RE
049B  30 7F                     br      _HalfLine
049D                    _EndDrawInv:

                        ; ****************************************************************************
                        ;                               Draw Shields
                        ; ****************************************************************************

049D  F8 09                     ldi     9                       ; Fix RE.1 again
049F  BE                        phi     re
04A0  F8 E7                     ldi     28*8+7                  ; RF point to shield area
04A2  AE                        plo     re
04A3                    _ShieldLoop:
04A3  F8 F0                     ldi     $F0                     ; draw a shield
04A5  73                        stxd
04A6  F8 0F                     ldi     $0F
04A8  73                        stxd
04A9  8E                        glo     re
04AA  FB C7                     xri     24*8+7                  ; do four rows
04AC  3A A3                     bnz     _ShieldLoop

                        ; ****************************************************************************
                        ;                               Draw Player
                        ; ****************************************************************************

04AE  F8 F0                     ldi     30*8                    ; draw the player
04B0  AE                        plo     re
04B1  F8 70                     ldi     $70
04B3  5E                        str     re
04B4  F8 F8                     ldi     31*8
04B6  AE                        plo     re
04B7  F8 50                     ldi     $50
04B9  5E                        str     re

                        ; ****************************************************************************
                        ;                               Reset data areas
                        ; ****************************************************************************

04BA  91                        ghi     r1                      ; set up variables (start at $800)
04BB  AF                        plo     rf

04BC  F8 09                     ldi     9                       ; set invader offset ($800)
04BE  5F                        str     rf
04BF  1F                        inc     rf
04C0  F8 02                     ldi     2                       ; set player offset ($801)
04C2  5F                        str     rf
04C3  1F                        inc     rf
04C4  F8 20                     ldi     8*4                     ; set invader count ($802)
04C6  5F                        str     rf
04C7  1F                        inc     rf
04C8  F8 02                     ldi     ISRight                 ; set invader status ($803)
04CA  5F                        str     rf
04CB  1F                        inc     rf
04CC  F8 60                     ldi     12*8                    ; set bottom scrolling line ($804)
04CE  5F                        str     rf

04CF  F8 20                     ldi     MTable                  ; erase all missiles
04D1  AF                        plo     rf
04D2  91                _MClear:ghi     r1                      ; fill the missile table with all zeroes
04D3  5F                        str     rf
04D4  1F                        inc     rf
04D5  8F                        glo     rf
04D6  FA 0F                     ani     MCount-1
04D8  3A D2                     bnz     _MClear

04DA  F8 04                     ldi 	LongBranchRoutine/256	; R6 is the long branch routine.
04DC  B6                        phi 	r6
04DD  F8 E3                     ldi 	LongBranchRoutine&255
04DF  A6                        plo 	r6
04E0  D6                        sep 	r6 						; and enter the main timer loop
04E1  0506                      dw 		_SetMainTmr

                        ; ****************************************************************************
                        ;
                        ;				Code replacement for LBR, SEP R6 ; DW nnnnn
                        ;
                        ; ****************************************************************************

04E3                    LongBranchRoutine:
04E3  43                		lda 	r3 						; get high byte
04E4  AA                		plo 	ra 						; save in RA.0
04E5  03                		ldn 	r3						; get low byte
04E6  A3                		plo 	r3						; put in R3.0
04E7  8A                		glo 	ra 						; put high byte in R3.1
04E8  B3                		phi 	r3
04E9  D3                		sep 	r3 						; and go there.
04EA  30 E3             		br 		LongBranchRoutine 		; it is re-entrant

                        ; ****************************************************************************
                        ;
                        ;                                 MAIN LOOP
                        ;
                        ; ****************************************************************************

0500                    		.org 	$500
0500  30 06                     br      _SetMainTmr
0502                    MainLoop:
0502  89                        glo     r9                      ; wait for loop to be >= 0
0503  FE                        shl
0504  33 02                     bdf     MainLoop
0506                    _SetMainTmr:
0506  F8 FE                     ldi     $FE
0508  A9                        plo     r9

                        ; ****************************************************************************
                        ;                               Move Invaders
                        ; ****************************************************************************

0509                    MoveInvaders:
0509  F8 02                     ldi     ICount                  ; read number of invaders
050B  AF                        plo     rf
050C  0F                        ldn     rf
050D  BB                        phi     rb                      ; save in RB.1

050E  F8 CE                     ldi     TmrInv                  ; check invader timer is zero
0510  AF                        plo     rf
0511  0F                        ldn     rf
0512  3A AB                     bnz    	NoMove

0514  9B                        ghi     rb                      ; use number of invaders as speed
0515  FC 08                     adi     8
0517  5F                        str     rf

0518  F8 CD                     ldi     SndTmr                  ; short "invaders moving" beep
051A  AF                        plo     rf
051B  F8 03                     ldi     3
051D  5F                        str     rf

051E  F8 4A                     ldi     <(XORMissiles)
0520  AA                        plo     ra
0521  F8 04                     ldi     >(XORMissiles)
0523  BA                        phi     ra
0524  DA                        sep     ra

0525  F8 03                     ldi     IStatus                 ; get current status, put in RB.1
0527  AF                        plo     rf
0528  4F                        lda     rf                      ; read it, point RF to IBase
0529  BB                        phi     rb

052A  9B                        ghi     rb                      ; look at current status
052B  F6                        shr                             ; shift LSB right into DF
052C  33 77                     bdf      _MoveDown
052E  32 3A                     bz       _MoveLeft               ; if zero then moving left

0530                    _MoveRight:
0530  F8 37                     ldi     <(ScrollRight)        ; set up to move right
0532  A4                        plo     r4
0533  F8 04                     ldi     >(ScrollRight)
0535  B4                        phi     r4
0536  F8 17                     ldi     $17                     ; base pointer for flip test
0538  30 42                     br      _HMoveEnd

053A                    _MoveLeft:
053A  F8 1E                     ldi     <(ScrollLeft)         ; set up to move left
053C  A4                        plo     r4
053D  F8 04                     ldi     >(ScrollLeft)
053F  B4                        phi     r4
0540  F8 10                     ldi     $10
0542                    _HMoveEnd:
0542  AD                        plo     rd                      ; save base pointer in RD

0543  F8 00                     ldi     IOffset                 ; point RF to offset : adjust IOffset
0545  AF                        plo     rf
0546  EF                        sex     rf                      ; use as index
0547  9B                        ghi     rb                      ; get value
0548  FA 02                     ani     $02                     ; 0 (left) 2 (right)
054A  FF 01                     smi     $01                     ; -1 (left) 1 (right)
054C  F4                        add                             ; add to IOffset
054D  5F                        str     rf                      ; save it back

054E  F8 04                     ldi     IBase                   ; point RF to base value
0550  AF                        plo     rf
0551  0F                        ldn     rf                      ; get base for scrolling
0552  AE                        plo     re                      ; set RE = scroll point
0553  9E                        ghi     re
0554  BD                        phi     rd                      ; RD contains the test value

0555                    _HScroll:
0555  D4                        sep     r4                      ; scroll a line
0556  8E                        glo     re                      ; reached the top (not top 2 lines)
0557  FA F0                     ani     $F0
0559  FB F0                     xri     $F0
055B  3A 55                     bnz    _HScroll

055D                    _TestReverse:
055D  91                        ghi     r1                      ; now test for the edge (R1.H = 0)
055E  ED                        sex     rd                      ; use RD which is $910 or $917
055F                    _TestOr:
055F  F1                        or                              ; OR the video byte
0560  AE                        plo     re                      ; save in RE.0
0561  8D                        glo     rd                      ; advance RD.0 by 8
0562  FC 08                     adi     $08
0564  AD                        plo     rd
0565  8E                        glo     re                      ; restore RE.0
0566  3B 5F                     bnf     _TestOr                 ; go back if not finished

0568  8D                        glo     rd                      ; look at < byte
0569  FA 01                     ani     $01                     ; if right this will be '1'
056B  3A 71                     bnz     _UseBit0
056D  8E                        glo     re                      ; shift bit 7 of RE.0 into bit 0
056E  7E                        shlc
056F  7E                        shlc
0570  AE                        plo     re
0571                    _UseBit0:
0571  8E                        glo     re                      ; look at the result
0572  F6                        shr                             ; shift bit 0 into carry
0573  3B AA                     bnf     ExitMoveInvaders        ; exit if zero
0575  30 A1                     br      NextState

0577                    _MoveDown:
0577  0F                        ldn     rf                      ; read the base value
0578  AE                        plo     re                      ; put in RE
0579  EE                        sex     re                      ; use RE as an index
057A  4E                        lda     re                      ; or all 8 bytes of the line together
057B  F1                        or                              ; +1
057C  60                        irx
057D  F1                        or                              ; +2
057E  60                        irx
057F  F1                        or                              ; +3
0580  60                        irx
0581  F1                        or                              ; +4
0582  60                        irx
0583  F1                        or                              ; +5
0584  60                        irx
0585  F1                        or                              ; +6
0586  60                        irx
0587  F1                        or                              ; +7
0588  32 93                     bz      _NoBShift               ; if non-zero the base shift is required

058A  0F                        ldn     rf                      ; if at the bottom, that's it.
058B  FB E0                     xri     $E0
058D  32 A1                     bz      NextState
058F  0F                        ldn     rf                      ; add 8 to the base value
0590  FC 08                     adi     $08
0592  5F                        str     rf

0593                    _NoBShift:
0593  0F                        ldn     rf                      ; RE points to the current line
0594  AE                        plo     re                      ; RD points to the previous line
0595  FC 08                     adi     8
0597  AD                        plo     rd
0598  9D                        ghi     rd
0599  BD                        phi     rd
059A                    _ScrollUp:                              ; now scroll by copying RD->RE
059A  2D                        dec     rd
059B  2E                        dec     re
059C  0E                        ldn     re
059D  5D                        str     rd
059E  8E                        glo     re
059F  3A 9A                     bnz     _ScrollUp

                        ; ****************************************************************************
                        ;                             Go to next state
                        ; ****************************************************************************

05A1                    NextState:
05A1  F8 03                     ldi     IStatus                 ; point RF to status
05A3  AF                        plo     rf
05A4  0F                        ldn     rf                      ; advance state counter
05A5  FC 01                     adi     $01
05A7  FA 03                     ani     $03
05A9  5F                        str     rf

05AA                    ExitMoveInvaders:
05AA  DA                        sep     ra
05AB                    NoMove:

                        ; ****************************************************************************
                        ;                               Move the Base
                        ; ****************************************************************************

05AB                    MoveBase:
05AB  F8 CF                     ldi     TmrPly                  ; check timer
05AD  AF                        plo     rf
05AE  0F                        ldn     rf                      ; skip if non-zero
05AF  3A E6                     bnz     ExitMoveBase
05B1  F8 02                     ldi     BaseSpd                 ; reset counter
05B3  5F                        str     rf
05B4  F8 01                     ldi     POffset                 ; make RF point to the offset
05B6  AF                        plo     rf

05B7  E3                        sex     r3                      ; index = program
05B8  62                        out     2                       ; select key 4
05B9  04                        .db     4
05BA  36 C2                     b3      _Left
05BC  62                        out     2                       ; select key 6
05BD  06                        .db     6
05BE  36 D1                     b3      _Right
05C0  30 E6             _ExitMB:br      ExitMoveBase

05C2  0F                _Left:  ldn     rf                      ; read player offset
05C3  FB 02                     xri     2                       ; check in range
05C5  32 C0                     bz      _ExitMB
05C7  F8 1E                     ldi     <(ScrollLeft)         ; set up to move left
05C9  A4                        plo     r4
05CA  F8 04                     ldi     >(ScrollLeft)
05CC  B4                        phi     r4
05CD  F8 FF                     ldi     $FF                     ; set -ve movement offset
05CF  30 DE                     br      _MovePlayer

05D1  0F                _Right: ldn     rf                      ; read player offset
05D2  FB 3D                     xri     61                      ; check in range
05D4  32 C0                     bz      _ExitMB
05D6  F8 37                     ldi     <(ScrollRight)        ; set up to move right
05D8  A4                        plo     r4
05D9  F8 04                     ldi     >(ScrollRight)
05DB  B4                        phi     r4
05DC  F8 01                     ldi     $01
05DE                    _MovePlayer:
05DE  EF                        sex     rf                      ; add movement offset to position
05DF  F4                        add
05E0  5F                        str     rf
05E1  F8 F8                     ldi     $F8
05E3  AE                        plo     re
05E4  D4                        sep     r4                      ; scroll two lines
05E5  D4                        sep     r4
05E6                    ExitMoveBase:

                        ; ****************************************************************************
                        ;                             Move missiles
                        ; ****************************************************************************

05E6  9F                        ghi     rf                      ; Make RC point to RAM
05E7  BC                        phi     rc
05E8  F8 20                     ldi     MTable                  ; RF Points to the invader table
05EA  AF                        plo     rf
05EB  D6                        sep 	r6 						; LBR to missile loop in new page
05EC  0600              		dw 		MILoop

0600                            org 	$600
0600  4F                MILoop: lda     rf                      ; Read position
0601  AE                        plo     re                      ; Save in RE.0 [Video Byte]
0602  0F                        ldn     rf                      ; Read Mask
0603  BB                        phi     rb                      ; Save in RB.1 [Mask Bit]
0604  2F                        dec     rf                      ; Fix RF
0605  EE                        sex     re                      ; Use video as index
0606  32 0C                     bz      _MNoErase               ; don't require erasing
0608  FB FF                     xri     $FF                     ; make an AND mask
060A  F2                        and                             ; and with screen
060B  5E                        str     re                      ; write it back
060C                    _MNoErase:
060C  9B                        ghi     rb                      ; look at mask
060D  32 44                     bz     _MCheckNew               ; if zero, check for new missile

060F                    _MMoveDown:
060F  8E                        glo     re                      ; move it down
0610  FC 08                     adi     8
0612  AE                        plo     re
0613  8F                        glo     rf                      ; get missile number
0614  FA 0F                     ani     $0F                     ; now 0 if player missile
0616  3A 1C                     bnz     _NotIMissile
0618  8E                        glo     re                      ; if so, it is going up.
0619  FF 10                     smi     16
061B  AE                        plo     re
061C                    _NotIMissile:
061C  8E                        glo     re                      ; check if reached top line
061D  FA F8                     ani     $F8
061F  32 2E                     bz      MIKill                  ; if reached the top line, die

0621  9B                        ghi     rb                      ; get mask
0622  F2                        and                             ; and with screen
0623  3A FE                     bnz    EnterCollide             ; if non zero, a collision

0625  8E                        glo     re                      ; check if reached line at $9F0
0626  FA F8                     ani     $F8
0628  FB F0                     xri     $F0
062A  32 2E                     bz      MIKill                  ; if so, kill it (missile missed)
062C  30 30                     br      MINext

062E  91                MIKill: ghi     r1                      ; zero the mask
062F  BB                        phi     rb
0630  EE                MINext: sex     re                      ; video as index
0631  9B                        ghi     rb                      ; look at mask
0632  32 36                     bz    	_MNoDraw
0634  F1                        or                              ; or with screen
0635  5E                        str     re                      ; write back
0636                    _MNoDraw:
0636  8E                        glo     re                      ; write it back
0637  5F                        str     rf
0638  1F                        inc     rf                      ; point at mask byte
0639  9B                        ghi     rb
063A  5F                        str     rf
063B  1F                        inc     rf                      ; point at next

063C  8F                        glo     rf                      ; reached the end ?
063D  FA 0F                     ani     (MCount-1)
063F  3A 00                     bnz    	MILoop                  ; go and do all of them
0641  D6                        sep 	r6 						; loop back.
0642  0502                     	dw      MainLoop

                        ; ****************************************************************************
                        ;          Come here when the mask is zero : check for new missile
                        ; ****************************************************************************

0644                    _MCheckNew:
0644  8F                        glo     rf                      ; look at missile
0645  FA 0F                     ani     $0F                     ; check if player
0647  32 96                     bz      _MCheckPlyr             ; if so, check for fire etc.

0649  F8 00                     ldi     IOffset                 ; read the invaders position
064B  AC                        plo     rc
064C  0C                        ldn     rc
064D  AA                        plo     ra                      ; save in RA.0

064E  F8 05                     ldi     RSeed
0650  AC                        plo     rc
0651  0C                        ldn     rc
0652  FC 07                     adi     7
0654  5C                        str     rc
0655  91                        ghi     r1                      ; point to $00nn
0656  B5                        phi     r5
0657  8A                        glo     ra
0658  E5                        sex     r5
0659  F3                        xor
065A  15                        inc     r5
065B  EC                        sex     rc
065C  F3                        xor

065D  BA                        phi     ra                      ; save number
065E  FA 1F                     ani     $1F                     ; only fire one in 8 times
0660  3A 2E                     bnz     MIKill

0662  9A                        ghi     ra                      ; upper 3 bits offset position
0663  F6                        shr                             ; put them in the 3 <est bits
0664  F6                        shr
0665  F6                        shr
0666  F6                        shr
0667  F6                        shr
0668  FE                        shl                             ; x 2 (we actually want x 6 in total)
0669  22                        dec     r2                      ; save in stack space
066A  52                        str     r2
066B  E2                        sex     r2                      ; access the stack
066C  8A                        glo     ra                      ; add to the base position
066D  F4                        add                             ; 3 lots of x2 = x6
066E  F4                        add
066F  F4                        add
0670  AA                        plo     ra                      ; update the base position
0671  12                        inc     r2                      ; fix the stack back

0672  F8 04                     ldi     IBase                   ; point RC to the base
0674  AC                        plo     rc
0675  8A                        glo     ra                      ; get the position
0676  F6                        shr                             ; divide it by 8
0677  F6                        shr
0678  F6                        shr
0679  EC                        sex     rc                      ; add the base position to it
067A  F4                        add
067B  FC 08                     adi     8                       ; add 8 more to it
067D  AE                        plo     re                      ; RE now points to it

067E  8A                        glo     ra                      ; use 3 <er bits as an index
067F  F9 F8                     ori     $F8                     ; into the table at $7F8 to get
0681  AA                        plo     ra                      ; the mask out.
0682  F8 07                     ldi     $07
0684  BA                        phi     ra
0685  0A                        ldn     ra                      ; read the mask
0686  BB                        phi     rb                      ; put in RB.H
0687  EE                        sex     re
0688  9B                _MoveUp:ghi     rb                      ; read mask
0689  F2                        and                             ; and with screen
068A  3A 0F                     bnz    _MMoveDown              	; if non-zero move it down and continue
068C  8E                        glo     re                      ; subtract 8 (move up one square)
068D  FF 08                     smi     8
068F  AE                        plo     re
0690  FA F8                     ani     $F8                     ; reached top line ?
0692  3A 88                     bnz     _MoveUp
0694  30 2E                     br      MIKill                 	; if so, kill it. There was no baddie
                                                                ; in that slot.
0696                    _MCheckPlyr:
0696  F8 10                     ldi     FButton                 ; point RF to fire button
0698  AC                        plo     rc
0699  E3                        sex     r3                      ; X = P
069A  62                        out     2                       ; test key 0
069B  00                        .db     0
069C  0C                        ldn     rc                      ; read fire
069D  FE                        shl                             ; shift old left
069E  3F A2                     bn4     _NoFirePressed
06A0  F9 01                     ori     1                       ; if fire pressed LSB = 1
06A2                    _NoFirePressed:
06A2  FA 03                     ani     3                       ; only interested in last two states
06A4  5C                        str     rc                      ; write back
06A5  FB 01                     xri     1                       ; if current 1, last 0
06A7  3A 30                     bnz    	MINext                  ; then drop through to fire

06A9  F8 01                     ldi     POffset                 ; point RC to player position
06AB  AC                        plo     rc
06AC  0C                        ldn     rc                      ; read it
06AD  F6                        shr                             ; divide by 8
06AE  F6                        shr
06AF  F6                        shr
06B0  FA 07                     ani     $07
06B2  FC E8                     adi     $E8                     ; work out initial position
06B4  AE                        plo     re
06B5  0C                        ldn     rc                      ; get it again
06B6  F9 F8                     ori     $F8                     ; pointer into table at $7F8
06B8  AC                        plo     rc
06B9  F8 07                     ldi     $07
06BB  BC                        phi     rc
06BC  0C                        ldn     rc                      ; read the pixel position
06BD  BB                        phi     rb                      ; put into mask position
06BE  30 30                     br     	MINext

06FE                            org 	$6FE
06FE                    EnterCollide:
06FE  F8 00             		ldi 	0
                        ; ****************************************************************************
                        ;                              Check for collision
                        ; ****************************************************************************
0700                    		org 	$700
0700                    _MICollide:
0700  8F                        glo     rf                      ; check if player missile collision
0701  FA 0F                     ani     $0F
0703  32 2B                     bz      _PMCollide

0705  8E                        glo     re                      ; check if player-inv missile collision
0706  FA F0                     ani     $F0
0708  FB F0                     xri     $F0
070A  32 15                     bz      _KillPlayer

070C                    _HitShield:
070C  9B                        ghi     rb                      ; if not, clear the relevant pixel
070D  FB FF                     xri     $FF                     ; (collision with shields or perhaps
070F  EE                        sex     re                      ; use video as index
0710  F2                        and                             ;  the player bullet) and kill it.
0711  5E                        str     re
0712                    _GoMIKill:
0712  D6                		sep 	r6        				; long branch to kill missiles
0713  062E                     	dw     	MIKill

0715                    _KillPlayer:
0715  F8 80                     ldi     128                     ; this forces a delay of about 2.5secs
0717  A9                        plo     r9
0718  9F                        ghi     rf                      ; point RC at the RAM
0719  BC                        phi     rc
071A  F8 CD                     ldi     SndTmr                  ; long beep
071C  AC                        plo     rc
071D  F8 3C                     ldi     60
071F  5C                        str     rc
0720  F8 0F                     ldi     PLives                  ; point RC at lives
0722  AC                        plo     rc
0723  0C                        ldn     rc                      ; decrement lives
0724  FF 01                     smi     1
0726  5C                        str     rc
0727  32 A5                     bz     	_EndGame
0729  30 12                     br     	_GoMIKill

072B                    _PMCollide:
072B  8E                        glo     re                      ; get the address
072C  FC 38                     adi     7*8                     ; check shield hit ?
072E  33 0C                     bdf     _HitShield              ; if in shield region pop shield

0730  9F                        ghi     rf                      ; set up RC to point to missile table
0731  BC                        phi     rc
0732  F8 22                     ldi     MTable+2                ; missing out the player missile
0734  AC                        plo     rc
0735  EC                        sex     rc                      ; use that as the index register
0736                    _CheckHitMissile:
0736  8E                        glo     re                      ; first compare the position
0737  F3                        xor
0738  3A 40                     bnz     _CHMNext
073A  1C                        inc     rc                      ; second compare the mask
073B  9B                        ghi     rb
073C  F3                        xor
073D  32 12                     bz     	_GoMIKill               ; if it is equal to the mask, kill it.
073F  2C                        dec     rc
0740                    _CHMNext:
0740  1C                        inc     rc                      ; move to the next one
0741  1C                        inc     rc
0742  8C                        glo     rc
0743  FA 0F                     ani     (MCount-1)              ; do for all the enemy missiles
0745  3A 36                     bnz     _CheckHitMissile

0747  8E                        glo     re                      ; down one row
0748  FC 08                     adi     8
074A  AE                        plo     re
074B  F8 02                     ldi     2                       ; move back two pixels
074D  AC                        plo     rc
074E                    _ShiftRight:
074E  9B                        ghi     rb                      ; shift mask right
074F  F6                        shr
0750  3B 55                     bnf     _NoCBack
0752  1E                        inc     re                      ; if carry out then next cell
0753  F8 80                     ldi     $80                     ; mask = $80
0755                    _NoCBack:
0755  BB                        phi     rb
0756  2C                        dec     rc
0757  8C                        glo     rc
0758  3A 4E                     bnz     _ShiftRight

075A  F8 03                     ldi     3                       ; do 3 rows
075C  AA                        plo     ra
075D  8E                        glo     re                      ; r7.0 := RE.0
075E  A7                        plo     r7
075F  9B                        ghi     rb                      ; r7.1 := RB.1
0760  B7                        phi     r7

0761                    _NextLine:
0761  97                        ghi     r7                      ; copy the mask back
0762  BB                        phi     rb
0763  F8 05                     ldi     5                       ; erase and go left 5 times
0765  AC                        plo     rc
0766                    _ShiftLeft:
0766  9B                        ghi     rb                      ; erase the pixel
0767  EE                        sex     re
0768  FB FF                     xri     $FF
076A  F2                        and
076B  5E                        str     re
076C  9B                        ghi     rb                      ; shift mask left
076D  FE                        shl
076E  3B 73                     bnf     _NoCForward             ; if carry out
0770  2E                        dec     re                      ; previous cell
0771  F8 01                     ldi     $01                     ; reset the mask
0773                    _NoCForward:
0773  BB                        phi     rb
0774  2C                        dec     rc
0775  8C                        glo     rc
0776  3A 66                     bnz    	_ShiftLeft
0778  87                        glo     r7                      ; get video address
0779  FF 08                     smi     8
077B  A7                        plo     r7                      ; update both working and fixed
077C  AE                        plo     re
077D  2A                        dec     ra                      ; do this for 3 lines up
077E  8A                        glo     ra
077F  3A 61                     bnz    	_NextLine

0781  9F                        ghi     rf                      ; RC points to ICount
0782  BC                        phi     rc
0783  F8 CD                     ldi     SndTmr                  ; Beep
0785  AC                        plo     rc
0786  F8 0C                     ldi     12
0788  5C                        str     rc
0789  F8 02                     ldi     ICount
078B  AC                        plo     rc
078C  0C                        ldn     rc                      ; decrement invader count
078D  FF 01                     smi     1
078F  5C                        str     rc
0790  32 A2                     bz      _GoNewLevel             ; if zero then new level (1 fewer on score)

0792  F8 0E                     ldi     PScore+3                ; Point RC to the score
0794  AC                        plo     rc
0795                    _IncScore:
0795  0C                        ldn     rc                      ; read next digit
0796  FC 01                     adi     1                       ; and increment by 1
0798  5C                        str     rc
0799  FB 0A                     xri     10                      ; reached 10
079B  3A 12                     bnz    	_GoMIKill               ; else kill the invader, continue
079D  91                        ghi     r1                      ; zero that one
079E  5C                        str     rc
079F  2C                        dec     rc                      ; do previous digit
07A0  30 95                     br      _IncScore

07A2                    _GoNewLevel:
07A2  D6                		sep 	r6 						; long branch to new level.
07A3  046C              		dw  	NewLevel

                        ; ****************************************************************************
                        ;                               Game Over
                        ; ****************************************************************************

      = 0210            NumIndexTab =   $0210                   ; Table of LSB of digit addresses

07A5                    _EndGame:
07A5  91                        ghi     r1                      ; D = 0
07A6  AE                        plo     re
07A7  EE                        sex     re                      ; use RF as index register
07A8  F8 09             _Clear2:ldi     $09                     ; RF = $0900
07AA  BE                        phi     re                      ; initialise RE.1, stays $09
07AB  91                        ghi     r1                      ; Write zero there
07AC  73                        stxd
07AD  8E                        glo     re
07AE  3A A8                     bnz     _Clear2
07B0  F8 42                     ldi     8*8+2                   ; Position score graphic
07B2  AE                        plo     re
07B3  F8 0B                     ldi     PScore                  ; Point RF to the score
07B5  AF                        plo     rf
07B6                    _ScoreLoop:
07B6  4F                        lda     rf                      ; read next score digit
07B7  FC 10                     adi     <(NumIndexTab)        ; point into table
07B9  AC                        plo     rc
07BA  F8 02                     ldi     >(NumIndexTab)
07BC  BC                        phi     rc
07BD  0C                        ldn     rc                      ; read the offset
07BE  AC                        plo     rc                      ; RC now points to the graphic data
07BF  F8 05                     ldi     5                       ; do 5 lines
07C1  AD                        plo     rd
07C2                    _DigitLoop:
07C2  4C                        lda     rc                      ; read graphic
07C3  5E                        str     re                      ; write to screen
07C4  8E                        glo     re                      ; go down one line
07C5  FC 08                     adi     8
07C7  AE                        plo     re
07C8  2D                        dec     rd                      ; loop round 5 times
07C9  8D                        glo     rd
07CA  3A C2                     bnz     _DigitLoop
07CC  8E                        glo     re                      ; next position
07CD  FC D9                     adi     -40+1
07CF  AE                        plo     re
07D0  8F                        glo     rf                      ; reached the end
07D1  FA 0F                     ani     $0F
07D3  3A B6                     bnz     _ScoreLoop

07D5  E3                WaitP10:sex     r3                      ; use PC as Index
07D6  62                        out     2                       ; scan for key 0
07D7  00                        .db     0
07D8  3E D8             _WaitK0:bn3     _WaitK0                 ; wait for key 0
07DA  D6                        sep 	r6
07DB  045D                      dw      Start                   ; and restart

07F8                            .org    $07F8                   ; this is a bitmask table
07F8  80402010 08040201         .db     $80,$40,$20,$10,$08,$04,$02,$01
0800                            .end

00000 Total Error(s)

BASESPD            0002 E  ENTERCOLLIDE       06FE    EXITMOVEBASE       05E6
EXITMOVEINVADERS   05AA    FBUTTON            0010 E  IBASE              0004 E
ICOUNT             0002 E  INVADERGR          0402    IOFFSET            0000 E
ISDOWNLEFT         0001 E  ISDOWNRIGHT        0003 E  ISLEFT             0000 E
ISRIGHT            0002 E  ISTATUS            0003 E  LIVES              0003 E
LONGBRANCHROUTINE  04E3    MAINLOOP           0502    MCOUNT             0010 E
MIKILL             062E    MILOOP             0600    MINEXT             0630
MOVEBASE           05AB    MOVEINVADERS       0509    MTABLE             0020 E
NEWLEVEL           046C    NEXTSTATE          05A1    NOMOVE             05AB
NUMINDEXTAB        0210 E  PLIVES             000F E  POFFSET            0001 E
PSCORE             000B E  R0                 0000 E  R1                 0001 E
R2                 0002 E  R3                 0003 E  R4                 0004 E
R5                 0005 E  R6                 0006 E  R7                 0007 E
R8                 0008 E  R9                 0009 E  RA                 000A E
RB                 000B E  RC                 000C E  RD                 000D E
RE                 000E E  RF                 000F E  RSEED              0005 E
SCROLLLEFT         041E    SCROLLRIGHT        0437    SNDTMR             00CD E
START              045D    TMRINV             00CE E  TMRPLY             00CF E
WAITP10            07D5    XORMISSILES        044A    _CHECKHITMISSILE   0736
_CHMNEXT           0740    _CLEAR             046F    _CLEAR2            07A8
_DIGITLOOP         07C2    _ENDDRAWINV        049D    _ENDGAME           07A5
_EXITMB            05C0    _GOMIKILL          0712    _GONEWLEVEL        07A2
_HALFLINE          047F    _HITSHIELD         070C    _HMOVEEND          0542
_HSCROLL           0555    _INCSCORE          0795    _KILLPLAYER        0715
_LEFT              05C2    _MCHECKNEW         0644    _MCHECKPLYR        0696
_MCLEAR            04D2    _MICOLLIDE         0700    _MMOVEDOWN         060F
_MNODRAW           0636    _MNOERASE          060C    _MOVEDOWN          0577
_MOVELEFT          053A    _MOVEPLAYER        05DE    _MOVERIGHT         0530
_MOVEUP            0688    _NEXTLINE          0761    _NOBSHIFT          0593
_NOCBACK           0755    _NOCFORWARD        0773    _NOFIREPRESSED     06A2
_NOSKIP            049A    _NOTIMISSILE       061C    _PMCOLLIDE         072B
_RIGHT             05D1    _SCORELOOP         07B6    _SCROLLUP          059A
_SETMAINTMR        0506    _SHIELDLOOP        04A3    _SHIFTLEFT         0766
_SHIFTRIGHT        074E    _SRIGHT0           0439    _TESTOR            055F
_TESTREVERSE       055D    _USEBIT0           0571    _WAITK0            07D8
_XOR1              044E    _XOR2              0455
